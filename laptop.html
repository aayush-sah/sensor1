<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SirenNet+ â€” Predictive Dashboard</title>
<style>
  :root{--card:#10182a;--muted:#9fb0c5;--ok:#50fa7b;--accent:#7ef0ff;--hot:#ff7eb6}
  *{box-sizing:border-box;font-family:Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif}
  body{margin:0;background:linear-gradient(180deg,#080c16,#0c1222);color:#e6edf3}
  header{padding:16px;border-bottom:1px solid #1f2947;background:#0b1221}
  main{padding:16px;max-width:1200px;margin:0 auto;display:grid;gap:16px}
  .card{background:var(--card);border:1px solid #1c2540;border-radius:18px;padding:16px;box-shadow:0 10px 30px rgba(0,0,0,.25)}
  textarea{width:100%;min-height:120px;border-radius:12px;border:1px solid #29314f;background:#0d1326;color:#e6edf3;padding:10px}
  button{background:#182443;border:1px solid #2a365e;color:#e6edf3;padding:10px 14px;border-radius:12px;cursor:pointer;transition:.2s}
  button:hover{transform:translateY(-1px);box-shadow:0 6px 20px rgba(0,0,0,.3)}
  .grid{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:12px}
  .pill{display:inline-block;padding:6px 10px;border-radius:999px;border:1px solid #2a365e;background:#121a33;font-size:12px;color:#b8c4d8;margin-right:8px}
  .alerts{display:grid;grid-template-columns:1fr;gap:10px;max-height:240px;overflow:auto}
  .alert{background:#121a33;border:1px solid #293862;border-radius:12px;padding:10px}
  .map{height:460px;border-radius:14px;border:1px solid #1e2a49;background:#0f172e}
  .devs{display:grid;grid-template-columns:repeat(auto-fill,minmax(260px,1fr));gap:12px}
  .dev{background:#0f172e;border:1px solid #233058;border-radius:14px;padding:12px}
  .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace;}
  .legend{display:flex;gap:10px;align-items:center;font-size:12px;color:#b8c4d8}
  .chip{display:inline-block;width:12px;height:12px;border-radius:3px;margin-right:6px}
</style>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
</head>
<body>
<header><h2>ðŸš¨ SirenNet+ â€” Predictive Dashboard</h2></header>
<main>
  <div class="card">
    <h3 style="margin-top:0">Connect a Phone</h3>
    <div class="grid">
      <div>
        <label>Paste Offer SDP</label>
        <textarea id="offerIn" class="mono"></textarea>
      </div>
      <div>
        <label>Answer SDP (copy back to phone)</label>
        <textarea id="answerOut" class="mono" readonly></textarea>
      </div>
    </div>
    <div style="margin-top:8px;">
      <button id="acceptBtn">Accept Offer & Create Answer</button>
      <span class="pill" id="rtcPill">ðŸ”— rtc: idle</span>
      <button id="csvBtn" style="float:right;">Export CSV</button>
    </div>
    <small>Connect multiple phones; each will stream siren detections with confidence + GPS.</small>
  </div>

  <div class="card">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
      <h3 style="margin:0">Live Map, Predictions & Alerts</h3>
      <div class="legend">
        <span class="chip" style="background:#7ef0ff"></span> Predicted Path
        <span class="chip" style="background:#ff7eb6"></span> Latest Centroids
      </div>
    </div>
    <div id="map" class="map"></div>
    <small>Tip: <b>Ctrl+Click</b> on the map to add a checkpoint (ETA is shown when a route is predicted). Drag markers to move them.</small>
    <div class="alerts" id="alerts" style="margin-top:10px"></div>
  </div>

  <div class="card">
    <h3 style="margin-top:0">Devices</h3>
    <div id="devs" class="devs"></div>
  </div>
</main>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
(()=>{
  const el=id=>document.getElementById(id);
  function setPill(ok,text){ const p=el('rtcPill'); p.textContent='ðŸ”— rtc: '+(text|| (ok?'connected':'idle')); p.style.color=ok?'#50fa7b':'#b8c4d8'; }

  const peers=[];
  const devices=new Map(); // name -> {marker,lastEl}
  const rows=[]; // for CSV of all raw messages
  const detections=[]; // array of {t:ms, lat, lon, conf, device}

  // Map setup
  const map = L.map('map').setView([23.2599,77.4126], 13);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{maxZoom:19, attribution:'Â© OpenStreetMap'}).addTo(map);

  const centroidMarkers = [];
  let predictedLine = null;
  const checkpoints = []; // markers with ETA labels
  map.on('click', (e)=>{
    if(!e.originalEvent.ctrlKey) return;
    const mk = L.marker(e.latlng, {draggable:true}).addTo(map).bindTooltip('Checkpoint', {permanent:true, direction:'right'}).openTooltip();
    checkpoints.push(mk);
  });

  function ensureDevice(name){
    if(devices.has(name)) return devices.get(name);
    const m = L.marker([0,0]).addTo(map).bindPopup(name);
    const box = document.createElement('div');
    box.className='dev';
    box.innerHTML = `<b>${name}</b><div class="mono small">Last: <span class="last">â€”</span></div>`;
    el('devs').appendChild(box);
    const rec = {marker:m, lastEl: box.querySelector('.last')};
    devices.set(name, rec);
    return rec;
  }

  function pushAlert(msg){
    const div=document.createElement('div');
    div.className='alert';
    const t = new Date(msg.ts).toLocaleTimeString();
    const where = msg.geo? ` @ ${msg.geo.lat.toFixed(5)}, ${msg.geo.lon.toFixed(5)}` : '';
    div.innerHTML=`<b>ðŸš¨ Siren</b> from <b>${msg.device}</b>${where} â€” confidence ${msg.confidence.toFixed(2)} <span class="mono">${t}</span>`;
    el('alerts').prepend(div);
    while(el('alerts').children.length>60) el('alerts').removeChild(el('alerts').lastChild);
  }

  function toRad(x){ return x*Math.PI/180; }
  function toDeg(x){ return x*180/Math.PI; }

  function haversine(a, b){
    const R=6371000; // meters
    const dLat = toRad(b.lat - a.lat);
    const dLon = toRad(b.lon - a.lon);
    const lat1 = toRad(a.lat), lat2 = toRad(b.lat);
    const h = Math.sin(dLat/2)**2 + Math.cos(lat1)*Math.cos(lat2)*Math.sin(dLon/2)**2;
    return 2*R*Math.asin(Math.sqrt(h));
  }

  function bearing(a,b){
    const lat1=toRad(a.lat), lat2=toRad(b.lat);
    const dLon = toRad(b.lon - a.lon);
    const y = Math.sin(dLon)*Math.cos(lat2);
    const x = Math.cos(lat1)*Math.sin(lat2) - Math.sin(lat1)*Math.cos(lat2)*Math.cos(dLon);
    const brng = Math.atan2(y,x);
    return (toDeg(brng)+360)%360;
  }

  function projectPoint(p, brngDeg, distM){
    const R=6371000;
    const br = toRad(brngDeg);
    const lat1=toRad(p.lat), lon1=toRad(p.lon);
    const lat2 = Math.asin(Math.sin(lat1)*Math.cos(distM/R) + Math.cos(lat1)*Math.sin(distM/R)*Math.cos(br));
    const lon2 = lon1 + Math.atan2(Math.sin(br)*Math.sin(distM/R)*Math.cos(lat1), Math.cos(distM/R)-Math.sin(lat1)*Math.sin(lat2));
    return {lat: toDeg(lat2), lon: (toDeg(lon2)+540)%360-180};
  }

  function recomputePrediction(){
    const now = Date.now();
    // keep last 90s of detections with conf>0.7 and GPS
    const filt = detections.filter(d => now - d.t < 90000 && d.conf > 0.7 && d.lat!=null && d.lon!=null);
    // bin into 2s windows -> weighted centroid by confidence
    const bins = new Map();
    for(const d of filt){
      const key = Math.floor(d.t / 2000); // 2s bin
      if(!bins.has(key)) bins.set(key, []);
      bins.get(key).push(d);
    }
    const centroids = [...bins.keys()].sort((a,b)=>a-b).map(k=>{
      const arr = bins.get(k);
      let wsum=0, lat=0, lon=0, tsum=0;
      for(const d of arr){ const w=d.conf; wsum+=w; lat+=w*d.lat; lon+=w*d.lon; tsum += w*d.t; }
      return {lat: lat/wsum, lon: lon/wsum, t: tsum/wsum};
    });
    // clear previous centroid markers
    centroidMarkers.forEach(m=>map.removeLayer(m));
    centroidMarkers.length = 0;
    centroids.slice(-5).forEach(c=>{
      const mk = L.circleMarker([c.lat, c.lon], {radius:6,color:'#ff7eb6', fillColor:'#ff7eb6', fillOpacity:0.8});
      mk.addTo(map);
      centroidMarkers.push(mk);
    });

    if(centroids.length < 2){
      if(predictedLine){ map.removeLayer(predictedLine); predictedLine=null; }
      checkpoints.forEach(m=>m.setTooltipContent('Checkpoint'));
      return;
    }
    const a = centroids[centroids.length-2];
    const b = centroids[centroids.length-1];
    const dist = haversine(a,b); // meters
    const dt = Math.max(0.5, (b.t - a.t)/1000); // seconds
    let speed = dist/dt; // m/s
    // clamp to a sane city speed (2..22 m/s -> ~7..80 km/h)
    speed = Math.max(2, Math.min(22, speed));
    const brng = bearing(a,b);

    // project next 60s in 5s steps
    const pts = [];
    let cur = {lat:b.lat, lon:b.lon};
    for(let t=5; t<=60; t+=5){
      cur = projectPoint(cur, brng, speed*5); // advance 5 seconds worth of distance
      pts.push([cur.lat, cur.lon]);
    }
    // draw predicted path
    if(predictedLine) map.removeLayer(predictedLine);
    predictedLine = L.polyline([[b.lat,b.lon], ...pts], {color:'#7ef0ff'}).addTo(map);

    // update ETA for checkpoints
    checkpoints.forEach(mk=>{
      const here = {lat: mk.getLatLng().lat, lon: mk.getLatLng().lng};
      const dTo = haversine({lat:b.lat, lon:b.lon}, here);
      const etaSec = dTo / speed;
      mk.setTooltipContent(`ETA ~ ${Math.round(etaSec)}s`);
    });
  }

  // periodic prediction update
  setInterval(recomputePrediction, 1000);

  function onMsg(obj){
    const name = obj.device||'Unknown';
    const rec = ensureDevice(name);
    if(obj.geo){ rec.marker.setLatLng([obj.geo.lat, obj.geo.lon]); rec.marker._popup.setContent(`${name}<br/>${obj.geo.lat.toFixed(5)}, ${obj.geo.lon.toFixed(5)}`); }
    rec.lastEl.textContent = `${obj.detected?'SIREN âœ…':'â€”'}  conf=${obj.confidence.toFixed(2)}  ${new Date(obj.ts).toLocaleTimeString()}`;
    rows.push([name, obj.ts, obj.detected?1:0, obj.confidence.toFixed(3), obj.geo?obj.geo.lat:'', obj.geo?obj.geo.lon:'']);
    if(obj.detected && obj.confidence>0.7 && obj.geo){
      detections.push({t: Date.parse(obj.ts)||Date.now(), lat: obj.geo.lat, lon: obj.geo.lon, conf: obj.confidence, device: name});
      pushAlert(obj);
    }
  }

  function pushAlert(obj){
    const div=document.createElement('div');
    div.className='alert';
    const t = new Date(obj.ts).toLocaleTimeString();
    const where = obj.geo? ` @ ${obj.geo.lat.toFixed(5)}, ${obj.geo.lon.toFixed(5)}` : '';
    div.innerHTML=`<b>ðŸš¨ Siren</b> from <b>${obj.device}</b>${where} â€” confidence ${obj.confidence.toFixed(2)} <span class="mono">${t}</span>`;
    el('alerts').prepend(div);
    while(el('alerts').children.length>60) el('alerts').removeChild(el('alerts').lastChild);
  }

  async function accept(){
    try{
      const offer = JSON.parse(el('offerIn').value);
      const pc = new RTCPeerConnection({iceServers:[{urls:['stun:stun.l.google.com:19302']}]});
      peers.push(pc);
      pc.oniceconnectionstatechange = ()=>{ if(pc.iceConnectionState==='connected') setPill(true,'connected'); };
      pc.ondatachannel = (ev)=>{
        const dc = ev.channel;
        dc.onopen = ()=> setPill(true,'connected');
        dc.onmessage = (e)=>{ try{ const obj = JSON.parse(e.data); if(obj.type==='siren') onMsg(obj); }catch(_){}};
      };
      await pc.setRemoteDescription(offer);
      const ans = await pc.createAnswer(); await pc.setLocalDescription(ans);
      pc.onicecandidate = ev => { el('answerOut').value = JSON.stringify(pc.localDescription); };
      el('answerOut').value = JSON.stringify(pc.localDescription);
    }catch(e){ alert('Bad Offer JSON'); }
  }

  function exportCSV(){
    let csv = 'device,ts_iso,detected,confidence,lat,lon\n' + rows.map(r=>r.join(',')).join('\n');
    const blob = new Blob([csv],{type:'text/csv'});
    const url = URL.createObjectURL(blob);
    const a=document.createElement('a'); a.href=url; a.download='sirennet_plus_events.csv'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
  }

  el('acceptBtn').addEventListener('click', accept);
  el('csvBtn').addEventListener('click', exportCSV);
})();
</script>
</body>
</html>
